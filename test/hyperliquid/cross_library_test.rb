# frozen_string_literal: true

require "test_helper"
require "json"

# Cross-library verification tests.
# These tests load test vectors generated by the official Python SDK
# and verify that the Ruby SDK produces byte-identical results.
#
# To regenerate vectors: python3 test/generate_test_vectors.py
class Hyperliquid::CrossLibraryTest < Minitest::Test
  PRIVATE_KEY = "0x0123456789012345678901234567890123456789012345678901234567890123"

  VECTORS = JSON.parse(
    File.read(File.expand_path("../fixtures/python_test_vectors.json", __dir__))
  )

  # ===========================================================================
  # FLOAT CONVERSION: float_to_wire
  # ===========================================================================

  VECTORS["float_to_wire"].each_with_index do |vec, i|
    define_method(:"test_float_to_wire_#{i}_#{vec["input"]}") do
      if vec.key?("error")
        assert_raises(Hyperliquid::SigningError) { Hyperliquid::Utils.float_to_wire(vec["input"]) }
      else
        assert_equal vec["output"], Hyperliquid::Utils.float_to_wire(vec["input"]),
                     "float_to_wire(#{vec["input"]}) mismatch"
      end
    end
  end

  # ===========================================================================
  # FLOAT CONVERSION: float_to_int_for_hashing
  # ===========================================================================

  VECTORS["float_to_int_for_hashing"].each_with_index do |vec, i|
    define_method(:"test_float_to_int_for_hashing_#{i}_#{vec["input"]}") do
      if vec.key?("error")
        assert_raises(Hyperliquid::SigningError) { Hyperliquid::Utils.float_to_int_for_hashing(vec["input"]) }
      else
        assert_equal vec["output"], Hyperliquid::Utils.float_to_int_for_hashing(vec["input"]),
                     "float_to_int_for_hashing(#{vec["input"]}) mismatch"
      end
    end
  end

  # ===========================================================================
  # FLOAT CONVERSION: float_to_usd_int
  # ===========================================================================

  VECTORS["float_to_usd_int"].each_with_index do |vec, i|
    define_method(:"test_float_to_usd_int_#{i}_#{vec["input"]}") do
      if vec.key?("error")
        assert_raises(Hyperliquid::SigningError) { Hyperliquid::Utils.float_to_usd_int(vec["input"]) }
      else
        assert_equal vec["output"], Hyperliquid::Utils.float_to_usd_int(vec["input"]),
                     "float_to_usd_int(#{vec["input"]}) mismatch"
      end
    end
  end

  # ===========================================================================
  # ORDER TYPE TO WIRE
  # ===========================================================================

  VECTORS["order_type_to_wire"].each_with_index do |vec, i|
    define_method(:"test_order_type_to_wire_#{i}") do
      input = symbolize_order_type(vec["input"])
      result = Hyperliquid::Utils.order_type_to_wire(input)
      assert_equal vec["output"], result,
                   "order_type_to_wire case #{i} mismatch"
    end
  end

  # ===========================================================================
  # ORDER REQUEST TO ORDER WIRE
  # ===========================================================================

  VECTORS["order_request_to_order_wire"].each_with_index do |vec, i|
    define_method(:"test_order_request_to_order_wire_#{i}") do
      order_type = symbolize_order_type(vec["order_type"])
      cloid = vec["cloid"] ? Hyperliquid::Cloid.from_str(vec["cloid"]) : nil
      req = {
        coin: "X", # not used in wire conversion
        is_buy: vec["is_buy"],
        sz: vec["sz"],
        limit_px: vec["limit_px"],
        order_type: order_type,
        reduce_only: vec["reduce_only"],
        cloid: cloid
      }
      result = Hyperliquid::Utils.order_request_to_order_wire(req, vec["asset"])
      assert_equal vec["output"], result,
                   "order_request_to_order_wire case #{i} mismatch"
    end
  end

  # ===========================================================================
  # ACTION HASH
  # ===========================================================================

  VECTORS["action_hash"].each_with_index do |vec, i|
    define_method(:"test_action_hash_#{i}_#{vec["action"]["type"]}") do
      signer = Hyperliquid::Signer.new(private_key: PRIVATE_KEY, base_url: Hyperliquid::MAINNET_URL)
      hash = signer.action_hash(
        vec["action"],
        nonce: vec["nonce"],
        vault_address: vec["vault_address"],
        expires_after: vec["expires_after"]
      )
      hash_hex = "0x#{hash.unpack1("H*")}"
      assert_equal vec["hash_hex"], hash_hex,
                   "action_hash case #{i} (#{vec["action"]["type"]}) mismatch"
    end
  end

  # ===========================================================================
  # L1 SIGNATURES (full r, s, v)
  # ===========================================================================

  VECTORS["l1_signatures"].each_with_index do |vec, i|
    network = vec["is_mainnet"] ? "mainnet" : "testnet"
    action_type = vec["action"]["type"]
    define_method(:"test_l1_signature_#{i}_#{action_type}_#{network}") do
      base_url = vec["is_mainnet"] ? Hyperliquid::MAINNET_URL : Hyperliquid::TESTNET_URL
      signer = Hyperliquid::Signer.new(private_key: PRIVATE_KEY, base_url: base_url)
      sig = signer.sign_l1_action(
        vec["action"],
        nonce: vec["nonce"],
        vault_address: vec["vault_address"],
        expires_after: vec["expires_after"]
      )
      assert_equal vec["r"], sig[:r],
                   "L1 sig r mismatch: case #{i} #{action_type} #{network}"
      assert_equal vec["s"], sig[:s],
                   "L1 sig s mismatch: case #{i} #{action_type} #{network}"
      assert_equal vec["v"], sig[:v],
                   "L1 sig v mismatch: case #{i} #{action_type} #{network}"
    end
  end

  # ===========================================================================
  # USER-SIGNED SIGNATURES (full r, s, v)
  # ===========================================================================

  VECTORS["user_signed_signatures"].each_with_index do |vec, i|
    network = vec["is_mainnet"] ? "mainnet" : "testnet"
    primary_type = vec["primary_type"]
    define_method(:"test_user_signed_#{i}_#{primary_type}_#{network}") do
      base_url = vec["is_mainnet"] ? Hyperliquid::MAINNET_URL : Hyperliquid::TESTNET_URL
      signer = Hyperliquid::Signer.new(private_key: PRIVATE_KEY, base_url: base_url)

      # Make a copy since sign_user_signed_action modifies the action
      action = deep_copy(vec["action"])
      payload_types = Hyperliquid::USER_SIGNED_TYPES[vec["primary_type"]]

      sig = signer.sign_user_signed_action(
        action,
        primary_type: vec["primary_type"],
        payload_types: payload_types
      )

      assert_equal vec["r"], sig[:r],
                   "User-signed sig r mismatch: case #{i} #{primary_type} #{network}"
      assert_equal vec["s"], sig[:s],
                   "User-signed sig s mismatch: case #{i} #{primary_type} #{network}"
      assert_equal vec["v"], sig[:v],
                   "User-signed sig v mismatch: case #{i} #{primary_type} #{network}"
    end
  end

  # ===========================================================================
  # PHANTOM AGENT CONSTRUCTION
  # ===========================================================================

  VECTORS["phantom_agent"].each_with_index do |vec, i|
    define_method(:"test_phantom_agent_#{i}") do
      # Verify phantom agent source field
      expected_source = vec["is_mainnet"] ? "a" : "b"
      assert_equal expected_source, vec["source"]
      # The connectionId should be the same hash bytes
      assert_equal vec["hash_hex"], vec["connectionId"]
    end
  end

  # ===========================================================================
  # ORDER WIRES TO ORDER ACTION
  # ===========================================================================

  VECTORS["order_wires_to_order_action"].each_with_index do |vec, i|
    define_method(:"test_order_wires_to_order_action_#{i}") do
      # Build the action the same way Ruby SDK does
      action = { "type" => "order", "orders" => vec["wires"], "grouping" => vec["grouping"] }
      action["builder"] = { "b" => vec["builder"]["b"].downcase, "f" => vec["builder"]["f"] } if vec["builder"]

      assert_equal vec["output"]["type"], action["type"]
      assert_equal vec["output"]["orders"], action["orders"]
      assert_equal vec["output"]["grouping"], action["grouping"]
      return unless vec["output"]["builder"]

      assert_equal vec["output"]["builder"], action["builder"]
    end
  end

  private

  def symbolize_order_type(order_type)
    if order_type.key?("limit") || order_type.key?(:limit)
      { limit: order_type["limit"] || order_type[:limit] }
    elsif order_type.key?("trigger") || order_type.key?(:trigger)
      t = order_type["trigger"] || order_type[:trigger]
      { trigger: { isMarket: t["isMarket"], triggerPx: t["triggerPx"], tpsl: t["tpsl"] } }
    else
      raise "Unknown order type: #{order_type}"
    end
  end

  def deep_copy(obj)
    JSON.parse(JSON.generate(obj))
  end
end
